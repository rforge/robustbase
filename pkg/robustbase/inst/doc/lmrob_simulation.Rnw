% -*- mode: noweb; noweb-default-code-mode: R-mode; -*-
\documentclass[a4paper]{article}

%\VignetteIndexEntry{lmrob_simulation.Rnw}

\usepackage{amsmath}
\usepackage{natbib}
\usepackage[utf8]{inputenc}

\newcommand{\makeright}[2]{\ifx#1\left\right#2\else#1#2\fi}
\newcommand{\Norm}[2][\left]{\mathcal N   #1( #2 \makeright{#1}{)}}
\newcommand{\bld}[1]{\boldsymbol{#1}} % shortcut for bold symbol
\newcommand{\T}[1]      {\texttt{#1}}
\DeclareMathOperator{\wgt}{w}
\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\median}{median}
\DeclareMathOperator{\mad}{mad}


\SweaveOpts{prefix.string=plot, eps = FALSE, pdf = TRUE, strip.white=TRUE}
\SweaveOpts{width=6, height=4}

%% \setlength{\textheight}{600pt}

\begin{document}
\setkeys{Gin}{width=\textwidth}
\setlength{\abovecaptionskip}{-5pt}

<<echo=FALSE,results=HIDE>>=
## set options
options(width=60)

## load required packages
require(robustbase)
require(ggplot2)
require(robust)
require(gtools)
require(gdata)
require(foreach)
registerDoSEQ()
## require(doMC)
## registerDoMC()

## Number of Repetitions:
N <- 1000

## default data set
dd <- data.frame(X1 = c(0.0707996949791054, 0.0347546309449992,                    
                   1.30548268152542, 0.866041511462982, 
                   0.275764343116733, 0.670798705161399, 
                   -0.549345193993536, -1.00640134962924, 
                   -1.22061169833477, -0.905619374719898,    
                   -0.678473241822565, 0.607011706444643, 
                   0.304237114526011, -2.14562816298790,     
                   2.34057395639167, 0.310752185537814, 
                   -0.972658170945796, 0.362012836241727,     
                   0.925888071796771, -0.595380245695561),
                 X2 = c(0.119970864158429,                
                   -0.738808741221796, 5.49659158913364, 
                   3.52149647048925, 2.02079730735676,        
                   3.82735326206246, -1.24025420267206, 
                   -4.37015614526438, -5.00575484838141,      
                   -3.56682651298729, -2.82581432351811, 
                   0.0456819251791285, -0.93949674689997,     
                   -8.08282316242221, 9.76283850058346, 
                   0.866426786132133, -2.90670860898916,      
                   2.95555226542630, 4.50904028657548, 
                   -3.44910596474065), 
                 X3 = c(1.11332914932289, 
                   3.55583356836222, 10.4937363250789, 
                   0.548517298224424, 1.67062103214174,       
                   0.124224367717813, 6.86425894634543,
                   1.14254475111985, 0.612987848127285,        
                   0.85062803777296, 0.881141283379239, 
                   0.650457856125926, 0.641015255931405,     
                   1.51667982973630, 0.764725309853834, 
                   1.61169179152476, 0.596312457754167,    
                   0.262270854360470, 1.24686336241, 
                   0.386112727548389))

## load functions
source('simulation.functions.R')
source('estimating.functions.R')
source('error.distributions.R')
source('graphics.functions.R')

## set estlist and parameters
estlist <- .estlist.confint
## nr. of repetitions
estlist$nrep <- N
estlist$seed <- 13082010
## set errors
estlist$errs <- c(estlist$errs,
                  list(.errs.skt.Inf.2,
                       .errs.skt.5.2,
                       .errs.cnorm..1.0.10,
                       .errs.cnorm..1.4.1))
## set the amount of trimming used in calculation of average results
trim <- 0.1

## set ggplot theme
theme <- theme_bw(base_size = 10)
theme$legend.key.size <- unit(1, "lines")
theme$plot.margin <- unit(c(1/2, 0, 0, 0), "lines")
theme_set(theme)
## set default sizes for lines and points
update_geom_defaults("point", aes(size = 4/3))
update_geom_defaults("line", aes(size = 1/4))
update_geom_defaults("hline", aes(size = 1/4))
update_geom_defaults("smooth", aes(size = 1/4))
## alpha value for plots with many points
alpha.error <- 0.3
alpha.n <- 0.4

trunc <- c(0.02, 0.14)
trunc.plot <- c(0.0185, 0.155)
f.truncate <- function(x, up = trunc.plot[2], low = trunc.plot[1]) {
  x[x > up] <- up
  x[x < low] <- low
  x
}
g.truncate.lines <- geom_hline(yintercept = trunc,
                               color = theme$panel.border()$gp$col)
g.truncate.line <- geom_hline(yintercept = trunc[2],
                               color = theme$panel.border()$gp$col)
g.truncate.areas <- annotate("rect", xmin=rep(-Inf,2), xmax=rep(Inf,2),
                             ymin=c(0,Inf), ymax=trunc,
                             fill = theme$panel.grid.major()$gp$col)
g.truncate.area <- annotate("rect", xmin=-Inf, xmax=Inf,
                             ymin=trunc[2], ymax=Inf,
                             fill = theme$panel.grid.major()$gp$col)

legend.mod <- list(`SMD(tau)` = expression(paste('SMD(',tau,')')),
                   `SMDM(tau)` = expression(paste('SMDM(',tau,')')),
                   `MM(Avar1)` = expression(paste('MM(',Avar[1],')')),
                   `MM(qT)` = expression(paste('MM(',q[T],')')),
                   `MM(qT,ssc)` = expression(paste('MM(',q[T],',ssc)')),
                   `MM(qE)` = expression(paste('MM(',q[E],')')),
                   `MM(qE,ssc)` = expression(paste('MM(',q[E],',ssc)')),
                   `sigma_S` = expression(hat(sigma)[S]),
                   `sigma_D` = expression(hat(sigma)[D]),
                   `sigma_S*qE` = expression(q[E]*hat(sigma)[S]),
                   `sigma_S*qT` = expression(q[T]*hat(sigma)[S]),
                   `sigma_robust` = expression(hat(sigma)[robust]),
                   `t1` = expression(t[1]),
                   `t3` = expression(t[3]),
                   `t5` = expression(t[5]),
                   `skt(Inf,2)` = expression(paste('skt(',infinity,',2)'))
                   )
@ 


\title{The choice of $\psi$: a simulation experiment with the enhanced
  \T{lmrob}} \author{Manuel Koller}
\maketitle
\tableofcontents

\section{Introduction}
In this vignette, we recreate the simulation study of \citet{KS2010}. This
vignette is supposed to complement the results presented in the above cited
reference and render its results reproducible. Another goal is to provide
simulation functions, that, with small changes, could also used for other
simulation studies. 

Additionally, in Section~\ref{sec:maximum-asymptotic-bias}, we calculate
the maximum asymptotic bias curves of the $\psi$-functions used in the
simulation.

\section{Setting}
The simulation setting used here is similar to the one in
\citet{maronna2009correcting}. We simulate $N = \Sexpr{N}$ repetitions. To
repeat the simulation, we recommend to use a small value of $N$ here, since
for large $n$ and $p$, computing all the replicates will take days.

\subsection{Methods}
We compare the methods
\begin{itemize}
\item MM, SMD, SMDM as described in \citet{KS2010}. These methods are
  available in the package \T{robustbase} (\T{lmrob}).
\item MM as implemented in the package \T{robust}  (\T{lmRob}). This method
  will be denoted as \emph{MM(robust)} later on.
\item MM using S-scale correction by $q_{\rm T}$ (\emph{MM(qT)}) and $q_{\rm
    E}$ (\emph{MM(qE)}) as proposed by \citet{maronna2009correcting}.
  
  $q_{\rm T}$ and $q_{\rm E}$ are defined as follows.
  \begin{equation*}
    q_{\rm E} = \frac{1}{1 - (1.29 - 6.02/n)p/n}
  \end{equation*}
  \begin{equation*}
    \hat q_{\rm T} = 1 + \frac{p}{2n}\frac{\hat a}{\hat b\hat c}
  \end{equation*}
  where
  \begin{equation*}
    \hat a = \frac{1}{n}\sum_{i=1}^n 
    \psi\left(\frac{r_i}{\hat\sigma_{\rm S}}\right)^2,
    \hat b = \frac{1}{n}
    \sum_{i=1}^n\psi'\left(\frac{r_i}{\hat\sigma_{\rm S}}\right),
    \hat c = \frac{1}{n}\sum_{i=1}^n
    \psi\left(\frac{r_i}{\hat\sigma_{\rm S}}\right)
    \frac{r_i}{\hat\sigma_{\rm S}}
  \end{equation*}
  with $\psi = \rho'$, $n$ the number of observations, $p$ the number of
  predictor variables, $\hat\sigma_{\rm S}$ is the S-scale estimate and
  $r_i$ is the residual of the $i$-th observation. 
  
  When using $q_{\rm E}$ it is necessary to adjust the tuning constants of
  $\chi$ to account for the dependence of $\kappa$ on $p$. For $q_{\rm T}$
  no change is required.
  
  This method in implemented as \T{lmrob.mar} in the source file
  \T{estimating.functions.R}. 
\end{itemize}

\subsection{$\psi$-functions}
We compare \emph{bisquare}, \emph{optimal}, \emph{lqq} and \emph{Hampel}
$\psi$-functions. They are illustrated in
Fig.~\ref{fig:psi.functions}. Note that the \emph{Hampel} $\psi$-function
is tuned to have a downward slope of $-1/3$ instead of the originally
proposed $-1/2$. This was set to allow for a comparison to an even slower
descending $\psi$-function.

\begin{figure}
\begin{center}
<<label=fig-psi-functions,fig=TRUE,echo=FALSE>>=
f.plot.psi <- function(x, psi) {
  cc <- lmrob.control(psi = psi)$tuning.psi
  data.frame(x=x, value=robustbase:::lmrob.psifun(x, cc, psi), psi = psi)
}
x <- seq(0, 10, length.out = 1000)
tmp <- rbind(f.plot.psi(x, 'optimal'),
             f.plot.psi(x, 'bisquare'),
             f.plot.psi(x, 'lqq'),
             f.plot.psi(x, 'hampel'))
print(ggplot(tmp, aes(x, value, color = psi)) + geom_line() +
      ylab(expression(psi(x))) +
      scale_color_discrete(name = expression(paste(psi, '-function'))))
@ 
\end{center}
\caption{$\psi$-functions used in the simulation}
\label{fig:psi.functions}
\end{figure}

\subsection{Designs}
Two types of designs are used in the simulation: fixed and random designs.
One design with $n=20$ observations, $p=1+3$ predictors and strong leverage
points. This design also includes an intercept column. It is shown in
Fig.~\ref{fig:design-predict}. The other designs are random, i.e.\
regenerated for every repetition, and the models are fitted without an
intercept. We use the same distribution to generate the designs as is used
for the errors. The number of observations simulated are $n = 25, 50, 100,
400$ and the ratio to the number of parameters are $p/n = 1/20, 1/10, 1/5,
1/3, 1/2$. We round $p$ to the nearest smaller integer if necessary.

The random datasets are generated using the following code.
<<results=HIDE,keep.source=TRUE>>=
f.gen <- function(n, p, rep, err) {
  ## get function name and parameters
  lerrfun <- f.errname(err$err)
  lerrpar <- err$args
  ## generate random predictors
  ret <- lapply(1:rep, function(...) {
    data.frame(matrix(do.call(lerrfun, c(n = n*p, lerrpar)), n, p))
  })
  attr(ret[[1]], 'gen') <- f.gen
  ret
}

ratios <- c(1/20, 1/10, 1/5, 1/3, 1/2)
lsit <- expand.grid(n = c(25, 50, 100, 400), p = ratios)
lsit <- within(lsit, p <- as.integer(n*p))
.errs.normal.1 <- list(err = 'normal',
                       args = list(mean = 0, sd = 1))
for (i in 1:NROW(lsit))
  assign(paste('rand',lsit[i,1],lsit[i,2],sep='_'),
         f.gen(lsit[i,1], lsit[i,2], 1, .errs.normal.1)[[1]])
@
An example design is shown in Fig.~\ref{fig:example.design}.

\begin{figure}
\begin{center}
<<label=fig-example-design,fig=TRUE,echo=FALSE>>=
print(plotmatrix(rand_25_5) +
      scale_x_continuous(breaks = -3:3) +
      scale_y_continuous(breaks = -3:3))
@ 
\end{center}
\caption{Example design}
\label{fig:example.design}
\end{figure}

\subsection{Error Distributions}
We simulate the following error distributions.
\begin{itemize}
% this works, but looks not so nice.
% \item  
% <<echo=FALSE,results=tex>>=
%   cat(paste(f.errs2str(estlist$errs),collapse='\n\\item '))
% @
\item Standard normal distribution,
\item $t_5$, $t_3$, $t_1$,
\item skewed t with $df = \infty, 5$ and $\gamma = 2$, as introduced by
  \citet{fernandez1998bayesian} using the \T{R} package \T{skewt}, 
\item contaminated normal with $10\%$ contamination with $\Norm{0, 10}$
  (symmetric) as well as $\Norm{4, 1}$ (asymmetric).
\end{itemize}

\subsection{Covariance Matrix Estimators}
For the standard MM estimator, we compare ${\rm Avar}_1$ of
\citet{croux03} and the empirical weighted covariance matrix estimate
corrected by Huber's small sample correction as described in
\citet{HubPR09}. The latter is also used for the variation of the MM
estimate proposed by \citet{maronna2009correcting}. For the
SMD and SMDM variants we use the covariance matrix estimate as described in
\citet{KS2010}.

The covariance matrix estimate consists of three parts:
\begin{equation*}
  % \label{eq:cov.matrix.est}
  {\rm cov}(\hat\beta) = \sigma^2\gamma\bld V_{\bld X}^{-1}.
\end{equation*}

The SMD and SMDM methods of \T{lmrob} use the following defaults.
\begin{equation*}
  % \label{eq:gamma}
  \gamma =
  \frac{\frac{1}{n}\sum_{i=1}^n
    \psi\left(\frac{r_i}{\tau_i\hat\sigma}\right)^2} 
  {\frac{1}{n}\sum_{i=1}^n\psi'\left(\frac{r_i}{\tau_i\hat\sigma}\right)}
\end{equation*}
where $\tau_i$ is the rescaling factor used for the D-scale estimate (see
\citet{KS2010}). 
\begin{equation*}
  % \label{eq:xwx}
  \bld{\widehat V}_{\bld X} = \frac{1}{\frac{1}{n}\sum_{i=1}^n\wgt_{ii}}\bld X'\bld W
  \bld X 
\end{equation*}
where $\bld W = \diag\left(\wgt\left(\frac{r_1}{\hat\sigma}\right), \dots,
  \wgt\left(\frac{r_n}{\hat\sigma}\right)\right)$. The function $\wgt(r) =
\psi(r)/r$ produces the robustness weights.

\section{Simulation}
The main loop of the simulation is fairly simple. (This code is only run if
there are no aggregate results available.)
<<results=HIDE,eval=FALSE>>=
if (!file.exists("aggr_results.Rdata")) {
  for (design in c("dd", mixedsort(ls(pattern = 'rand_\\d+_\\d+')))) {
    print(design)
    ## set design
    estlist$design <- get(design)
    estlist$use.intercept <- !grepl('^rand', design)
    ## add design.predict: pc
    estlist$design.predict <-
      if (is.null(attr(estlist$design, 'gen')))
        f.prediction.points(estlist$design) else
      f.prediction.points(estlist$design, max.pc = 2)
    
    filename <- sprintf('r.test.final.%s.Rdata',design)
    if (!file.exists(filename)) {
      ## run
      print(system.time(r.test <- f.sim(estlist, silent = TRUE)))
      ## save
      save(r.test, file=filename)
      ## delete output
      rm(r.test)
      ## run garbage collection
      gc()
    }
  }
}
@ 

The variable \T{estlist} is a list containing all the necessary
settings required to run the simulation as outlined above.  Most of its
elements are self-explanatory.
<<>>=
str(estlist, 1)
@ 

\T{errs} is a list containing all the error distributions to be
simulated. The entry for the standard normal looks as follows.
<<>>=
estlist$errs[[1]]
@ 
\T{err} is translated internally to the corresponding random generation or
quantile function, e.g.\ in this case \T{rnorm} or \T{qnorm}. \T{args}
is a sublist containing all the required arguments to call the
function. The errors are then generated internally with the following call.
<<eval=FALSE>>=
set.seed(estlist$seed)
errs <- c(sapply(1:nrep, function(x) do.call(fun, c(n = nobs, args))))
@
All required random numbers are generated at once instead of during the
simulation. Like this, it is certain, that all the compared methods run on
exactly the same data.

The entry \T{procedures} follows a similar convention. \T{design.predict}
contains the design used for the prediction of observations and calculation
of confidence or prediction intervals. The objects returned by the
procedures are processed by the functions contained in the
\T{estlist\$output} list.
<<>>=
str(estlist$output[1:3], 2)
@ 
The results are stored in a 4-dimensional array. The dimensions are:
repetition number, type of value, procedure id, error id. Using \T{apply}
it is very easy and fast to generate summary statistics. The raw results
are stored on the hard disk, because typically it takes much longer to
execute all the procedures than to calculate the summary statistics. The
variables saved take up a lot of space quite quickly, so only the necessary
data is stored. These are $\sigma$, $\bld\beta$ as well as the
corresponding standard errors. 

To speed up the simulation routine \T{f.sim}, the simulations are carried
out in parallel, as long as this is possible. This is accomplished with the
help of the \T{R}-package \T{foreach}. This is most easily done on a
machine with multiple processors or cores. The \T{multicore} package
provides the methods to do so easily. The worker processes are just forked
from the main \T{R} process.

After all the methods have been simulated, the simulation output is
processed. The code is quite lengthy and thus not displayed here (check the
Sweave source file \T{lmrob\_simulation.Rnw}). The
residuals, robustness weights, leverages and $\tau$ values have to be
recalculated. Using vectorized operations and some specialized \T{C} code,
this is quite cheap. The summary statistics generated are discussed in the
next section.

<<results=HIDE,echo=FALSE>>=
if (!file.exists("aggr_results.Rdata")) { 
  res <- foreach(file = list.files('./', pattern = 'r.test.final\\.')) %dopar% {
    ## get design, load r.test, initialize other stuff
    design <- substr(file, 14, nchar(file) - 6)
    cat(design, ' ')
    load(file)
    estlist <- attr(r.test, 'estlist')
    use.intercept <- 
      if (!is.null(estlist$use.intercept)) estlist$use.intercept else TRUE
    sel <- dimnames(r.test)[[3]][dimnames(r.test)[[3]] != "estname=lm"]
    n.betas <- paste('beta',1:(NCOL(estlist$design)+use.intercept),sep='_')
    ## get design                    
    lX <- if (use.intercept)
      as.matrix(cbind(1, get(design))) else as.matrix(get(design))
    n <- NROW(lX)
    p <- NCOL(lX)
    ## prepare arrays for variable designs and leverages
    if (is.function(attr(estlist$design, 'gen'))) {
      lXs <- array(NA, c(n, NCOL(lX), dim(r.test)[c(1, 4)]),
                   list(Obs = NULL, Pred = colnames(lX), Data = NULL,
                        Errstr = dimnames(r.test)[[4]]))
    }
    ## generate errors
    lerrs <- array(NA, c(n, dim(r.test)[c(1,4)]) ,
                   list(Obs = NULL, Data = NULL, Errstr = dimnames(r.test)[[4]]))
    for (i in 1:dim(lerrs)[3]) {
      lerrstr <- f.list2str(estlist$errs[[i]])
      lerr <- f.errs(estlist, estlist$errs[[i]], 
                     gen = attr(estlist$design, 'gen'),
                     nobs = n, npar = NCOL(lX))
      lerrs[,,lerrstr] <- lerr
      if (!is.null(attr(lerr, 'designs'))) {
        ## retrieve generated designs: this returns a list of designs
        lXs[,,,i] <- unlist(attr(lerr, 'designs'))
        if (use.intercept)
          stop('intercept not implemented for random desings')
      }
      rm(lerr)
    }
    if (is.function(attr(estlist$design, 'gen'))) {
      ## calculate leverages
      lXlevs <- apply(lXs, 3:4, robustbase:::lmrob.leverages)
    }
    ## calculate fitted values from betas
    if (!is.function(attr(estlist$design, 'gen'))) { ## fixed design case
      lfitted <- apply(r.test[,n.betas,sel,,drop=FALSE],c(3:4),
                       function(bhat) { lX %*% t(bhat) } )
    } else { ## variable design case
      lfitted <- array(NA, n*prod(dim(r.test)[c(1,4)])*length(sel))
      lfitted <- .C('R_calc_fitted',
                    as.double(lXs), ## designs
                    as.double(r.test[,n.betas,sel,,drop=FALSE]), ## betas
                    as.double(lfitted), ## result
                    as.integer(n), ## n
                    as.integer(p), ## p
                    as.integer(dim(r.test)[1]), ## nrep
                    as.integer(length(sel)), ## n procstr
                    as.integer(dim(r.test)[4]), ## n errstr
                    DUP=FALSE, NAOK=TRUE, PACKAGE="robustbase")[[3]]
    }
    tdim <- dim(lfitted) <-
      c(n, dim(r.test)[1], length(sel),dim(r.test)[4])
    lfitted <- aperm(lfitted, c(1,2,4,3))
    ## calculate residuals = y - fitted.values
    lfitted <- as.vector(lerrs) - as.vector(lfitted)
    dim(lfitted) <- tdim[c(1,2,4,3)]
    lfitted <- aperm(lfitted, c(1,2,4,3))
    dimnames(lfitted) <-
      c(list(Obs = NULL), dimnames(r.test[,,sel,,drop=FALSE])[c(1,3,4)])
    lresids <- lfitted
    rm(lfitted)
    ## calculate lm MSE and trim trimmed MSE of betas
    tf.MSE <- function(lbetas) {
      lnrm <- rowSums(lbetas^2)
      c(MSE=mean(lnrm,na.rm=TRUE),MSE.1=mean(lnrm,trim=trim,na.rm=TRUE))
    }
    MSEs <- apply(r.test[,n.betas,,,drop=FALSE],3:4,tf.MSE)
    li <- 1 ## so we can reconstruct where we are
    lres <- apply(lresids,3:4,f.aggregate.results <- {
      function(lresid) {    
        ## the counter li tells us, where we are
        ## we walk dimensions from left to right
        lcdn <- f.get.current.dimnames(li, dimnames(lresids), 3:4)
        lr <- r.test[,,lcdn[1],lcdn[2]]
        ## update counter
        li <<- li + 1
        ## convert procstr to proclst and get control list
        largs <- f.str2list(lcdn[1])[[1]]$args
        if (grepl('lm.robust', lcdn[1])) {
          lctrl <- list()
          lctrl$psi <- toupper(largs$weight2)
          lctrl$tuning.psi <-
            f.eff2c.psi(largs$efficiency, lctrl$psi)
          lctrl$method <- 'MM'
        } else {
          lctrl <- do.call('lmrob.control',largs)
        }
        ## transpose and normalize residuals with sigma
        lresid <- t(lresid) / lr[,'sigma']
        ## calculate correction factors
        ## A
        lsp2 <- rowSums(robustbase:::lmrob.psifun(lresid,lctrl$tuning.psi,
                                                  lctrl$psi)^2)
        ## B
        lspp <- rowSums(lpp <- robustbase:::lmrob.psifun(lresid,lctrl$tuning.psi,
                                                         lctrl$psi,1))
        ## calculate Huber\'s small sample correction factor
        lK <- 1 + rowSums((lpp - lspp/n)^2)*NCOL(lX)/lspp^2 ## 1/n cancels
        ## only calculate tau variants if possible
        if (grepl('args.method=\\w*(D|T)\\w*\\b', lcdn[1])) { ## SMD or SMDM
          ## calculate robustness weights
          lwgts <- robustbase:::lmrob.wgtfun(lresid,lctrl$tuning.psi, lctrl$psi)
          ## function to calculate robustified leverages
          tfun <- if (is.function(attr(estlist$design, 'gen'))) 
            function(i) {
              if (all(is.na(lwgts[i,]))) lwgts[i,] else 
              robustbase:::lmrob.leverages(lXs[,,i,lcdn[2]],lwgts[i,])
            } else function(i) {
              if (all(is.na(lwgts[i,]))) lwgts[i,] else 
              robustbase:::lmrob.leverages(lX,lwgts[i,])
            }
          llev <- sapply(1:dim(r.test)[1], tfun)
          ## calculate unique leverages
          lt <- robustbase:::lmrob.tau(list(),h=llev,control=lctrl)
          ## normalize residuals with tau (transpose lresid)
          lresid <- t(lresid) / lt
          ## A
          lsp2t <- colSums(robustbase:::lmrob.psifun(lresid,lctrl$tuning.psi,
                                                   lctrl$psi)^2)
          ## B
          lsppt <- colSums(robustbase:::lmrob.psifun(lresid,lctrl$tuning.psi,
                                                   lctrl$psi,1))
        } else {
          lsp2t <- lsppt <- NA
        }

        ## calculate raw scales based on the errors
        lproc <- f.str2list(lcdn[1])[[1]]
        q <- NA
        M <- NA
        if (lproc$estname == 'lmrob.mar' && lproc$args$type == 'qE') {
          ## for lmrob_mar, qE variant
          lctrl <- lmrob.control(psi = 'bisquare',
                                 tuning.chi=uniroot(function(c) 
                                   robustbase:::lmrob.bp('bisquare', c) - (1-p/n)/2,
                                   c(1, 3))$root)
          se <- apply(lerrs[,,lcdn[2]],2,lmrob.mscale,control=lctrl,p=p)
          ltmp <- se/lr[,'sigma']
          q <- median(ltmp, na.rm = TRUE)
          M <- mad(ltmp, na.rm = TRUE)
        } else if (!is.null(lproc$args$method) && lproc$args$method == 'SMD') {
          ## for D-scales
          se <- apply(lerrs[,,lcdn[2]],2,lmrob.dscale,control=lctrl,
                      kappa=robustbase:::lmrob.kappa(control=lctrl))
          ltmp <- se/lr[,'sigma']
          q <- median(ltmp, na.rm = TRUE)
          M <- mad(ltmp, na.rm = TRUE)
        }

        ## calculate empirical correct test value (to yield 5% level)
        t.val_2 <- t.val_1 <- quantile(abs(lr[,'beta_1']/lr[,'se_1']), 0.95, 
                                       na.rm = TRUE)
        if (p > 1) t.val_2 <- quantile(abs(lr[,'beta_2']/lr[,'se_2']), 0.95, 
                                       na.rm = TRUE)

        ## return output: summary statistics: 
        c(## gamma
          AdB2.1 = mean(lsp2/lspp^2,trim=trim,na.rm=TRUE)*n, 
          K2AdB2.1 = mean(lK^2*lsp2/lspp^2,trim=trim,na.rm=TRUE)*n,
          AdB2t.1 = mean(lsp2t/lsppt^2,trim=trim,na.rm=TRUE)*n, 
          sdAdB2.1 = sd.trim(lsp2/lspp^2*n,trim=trim,na.rm=TRUE), 
          sdK2AdB2.1 = sd.trim(lK^2*lsp2/lspp^2*n,trim=trim,na.rm=TRUE),
          sdAdB2t.1 = sd.trim(lsp2t/lsppt^2*n,trim=trim,na.rm=TRUE), 
          ## sigma
          medsigma = median(lr[,'sigma'],na.rm=TRUE),
          madsigma = mad(lr[,'sigma'],na.rm=TRUE),
          meansigma.1 = mean(lr[,'sigma'],trim=trim,na.rm=TRUE),
          sdsigma.1 = sd.trim(lr[,'sigma'],trim=trim,na.rm=TRUE),
          meanlogsigma = mean(log(lr[,'sigma']),na.rm=TRUE),
          meanlogsigma.1 = mean(log(lr[,'sigma']),trim=trim,na.rm=TRUE),
          sdlogsigma = sd(log(lr[,'sigma']),na.rm=TRUE),
          sdlogsigma.1 = sd.trim(log(lr[,'sigma']),trim=trim,na.rm=TRUE),
          q = q,
          M = M,
          ## beta
          efficiency.1 = MSEs['MSE.1','estname=lm',lcdn[2]] /
          MSEs['MSE.1',lcdn[1],lcdn[2]],
          ## t-value: level
          emplev_1 = mean(abs(lr[,'beta_1']/lr[,'se_1']) > qt(0.975, n - p),
            na.rm = TRUE),
          emplev_2 = if (p>1) {
            mean(abs(lr[,'beta_2']/lr[,'se_2']) > qt(0.975, n - p), na.rm = TRUE) 
          } else NA,
          ## t-value: power
          power_1_0.2 = mean(abs(lr[,'beta_1']-0.2)/lr[,'se_1'] > t.val_1,
            na.rm = TRUE),
          power_2_0.2 = if (p>1) {
            mean(abs(lr[,'beta_2']-0.2)/lr[,'se_2'] > t.val_2, na.rm = TRUE) 
          } else NA,
          power_1_0.4 = mean(abs(lr[,'beta_1']-0.4)/lr[,'se_1'] > t.val_1, 
            na.rm = TRUE),
          power_2_0.4 = if (p>1) { 
            mean(abs(lr[,'beta_2']-0.4)/lr[,'se_2'] > t.val_2, na.rm = TRUE) 
          } else NA,
          power_1_0.6 = mean(abs(lr[,'beta_1']-0.6)/lr[,'se_1'] > t.val_1,
            na.rm = TRUE),
          power_2_0.6 = if (p>1) {
            mean(abs(lr[,'beta_2']-0.6)/lr[,'se_2'] > t.val_2, na.rm = TRUE) 
          } else NA,
          power_1_0.8 = mean(abs(lr[,'beta_1']-0.8)/lr[,'se_1'] > t.val_1,
            na.rm = TRUE),
          power_2_0.8 = if (p>1) { 
            mean(abs(lr[,'beta_2']-0.8)/lr[,'se_2'] > t.val_2, na.rm = TRUE) 
          } else NA,
          power_1_1 = mean(abs(lr[,'beta_1']-1)/lr[,'se_1'] > t.val_1, 
            na.rm = TRUE),
          power_2_1 = if (p>1) {
            mean(abs(lr[,'beta_2']-1)/lr[,'se_2'] > t.val_2, na.rm = TRUE) 
          } else NA,
          ## coverage probability: calculate empirically
          ## the evaluation points are constant, but the designs change
          ## therefore this makes only sense for fixed designs
          cpr_1 = mean(lr[,'upr_1'] < 0 | lr[,'lwr_1'] > 0, na.rm = TRUE),
          cpr_2 = mean(lr[,'upr_2'] < 0 | lr[,'lwr_2'] > 0, na.rm = TRUE),
          cpr_3 = mean(lr[,'upr_3'] < 0 | lr[,'lwr_3'] > 0, na.rm = TRUE),
          cpr_4 = mean(lr[,'upr_4'] < 0 | lr[,'lwr_4'] > 0, na.rm = TRUE),
          cpr_5 = if (any(colnames(lr) == 'upr_5')) { 
            mean(lr[,'upr_5'] < 0 | lr[,'lwr_5'] > 0, na.rm = TRUE) } else NA,
          cpr_6 = if (any(colnames(lr) == 'upr_6')) { 
            mean(lr[,'upr_6'] < 0 | lr[,'lwr_6'] > 0, na.rm = TRUE) } else NA,
          cpr_7 = if (any(colnames(lr) == 'upr_7')) { 
            mean(lr[,'upr_7'] < 0 | lr[,'lwr_7'] > 0, na.rm = TRUE) } else NA
          )
      }})
    
    ## convert to data.frame
    lres <- f.a2df.2(lres, split = '___NO___')
    ## add additional info
    lres$n <- NROW(lX)
    lres$p <- NCOL(lX)
    lres$nmpdn <- with(lres, (n-p)/n)
    lres$Design <- design

    ## lres[,c('Method', 'Psi', 'Error', 'efficiency.1')]
    ## ggplot(subset(lres, Error != 't1'), aes(Error, efficiency.1, color = Method)) + 
    ##   geom_point() + geom_hline(yintercept = 0.95) + 
    ##   facet_wrap(~ Psi)

    ## clean up
    rm(r.test, lXs, lXlevs, lresids, lerrs)
    gc()
    ## return lres
    lres
  } 
  save(res, trim, file = 'aggr_results.Rdata')
} else load('aggr_results.Rdata')

## combine list elements to data.frame
test.1 <- do.call('rbind', res)
test.1 <- within(test.1, {
  Method[Method == "SM"] <- "MM"
  Method <- drop.levels(Method, reorder = FALSE)
  Estimator <- interaction(Method, D.type, drop = TRUE)
  Estimator <- f.rename.level(Estimator, 'MM.S', 'MM')
  Estimator <- f.rename.level(Estimator, 'SMD.D', 'SMD')
  Estimator <- f.rename.level(Estimator, 'SMDM.D', 'SMDM')
  Estimator <- f.rename.level(Estimator, 'MM.qT', 'MM(qT)')
  Estimator <- f.rename.level(Estimator, 'MM.qE', 'MM(qE)')
  Estimator <- f.rename.level(Estimator, 'MM.rob', 'MM(robust)')
  Est.Scale <- f.rename.level(Estimator, 'MM', 'sigma_S')
  Est.Scale <- f.rename.level(Est.Scale, 'MM(robust)', 'sigma_robust')
  Est.Scale <- f.rename.level(Est.Scale, 'MM(qE)', 'sigma_S*qE')
  Est.Scale <- f.rename.level(Est.Scale, 'MM(qT)', 'sigma_S*qT')
  Est.Scale <- f.rename.level(Est.Scale, 'SMDM', 'sigma_D')
  Est.Scale <- f.rename.level(Est.Scale, 'SMD', 'sigma_D')
  Psi <- f.rename.level(Psi, 'hampel', 'Hampel')
})
## add interaction of Method and Cov
test.1 <- within(test.1, {
  method.cov <- interaction(Estimator, Cov, drop=TRUE)
  levels(method.cov) <-
    sub('\\.+vcov\\.(a?)[wacrv1]*', '\\1', levels(method.cov))
  method.cov <- f.rename.level(method.cov, "MMa", "MM(Avar1)")
  method.cov <- f.rename.level(method.cov, "MM(robust).Default", "MM(robust)")
  method.cov <- f.rename.level(method.cov, "MM", "MM(ssc)")
  method.cov <- f.rename.level(method.cov, "SMD", "SMD(tau)")
  method.cov <- f.rename.level(method.cov, "SMDM", "SMDM(tau)")
  method.cov <- f.rename.level(method.cov, "MM(qT)", "MM(qT,ssc)")
  method.cov <- f.rename.level(method.cov, "MM(qE)", "MM(qE,ssc)")
  })
## add desired ratios:
test.1$ratio <- ratios[apply(abs(as.matrix(1/ratios) %*%
                                 t(as.matrix(test.1$p / test.1$n)) - 1),
                             2, which.min)]

test.1 <- drop.levels(test.1[!test.1$Psi %in% c('welsh', 'ggw'),], reorder = FALSE)
test.1$Psi <- reorder(test.1$Psi, new.order = c('optimal', 'bisquare', 'lqq', 'Hampel'))

## calculate expected values of psi^2 and psi'
test.1$Ep2 <- test.1$Epp <- NA
for(Procstr in levels(test.1$Procstr)) {
  args <- f.str2list(Procstr)[[1]]$args
  lctrl <- do.call('lmrob.control',args)
  test.1$Ep2[test.1$Procstr == Procstr] <-
    robustbase:::lmrob.E(psi(r)^2, lctrl, use.integrate = TRUE)
  test.1$Epp[test.1$Procstr == Procstr] <-
    robustbase:::lmrob.E(psi(r,1), lctrl, use.integrate = TRUE)
}
## drop some observations, separate fixed and random designs
test.fixed <- drop.levels(subset(test.1, n == 20), reorder = FALSE)
test.1 <- drop.levels(subset(test.1, n != 20), reorder = FALSE)
test.2 <- drop.levels(subset(test.1, Error == 'N(0,1)'), reorder = FALSE)
test.3 <- drop.levels(subset(test.2, Method != 'SMDM'), reorder = FALSE)
test.4 <- drop.levels(subset(test.1, Method != 'SMDM'), reorder = FALSE)
coords <- coord_cartesian(ylim = c(0.5, 1.7))
@ 

\section{Simulation Results}
\subsection{Criteria}
The simulated methods are compared using the following criteria. 
\begin{itemize}
\item \textbf{Scale estimates.} The criteria for scale estimates are all
  calculated on the log-scale. The bias of the estimators is measured by
  the $\Sexpr{trim*100}\%$ trimmed mean. To recover a meaningfun scale, the
  results are exponatiated before plotting. It is easy to see that this is
  equivalent to calculating the geometric mean. Since the methods are all
  tuned at the central model, ${\mathcal N}(0,1)$, a meaningful comparison
  can only be made for ${\mathcal N}(0,1)$ distributed errors.  

  The variability of the estimators, on the other hand, can be compared
  over all simulated error distributions. It is measured by the
  $\Sexpr{trim*100}\%$ trimmed standard deviation, rescaled by the square
  root of the number of observations.

  For completeness, the statistics used to compare scale estimates in
  \citet{maronna2009correcting} are also calculated. They are defined as
  \begin{equation}
    \label{eq:def.q.and.M}
    q = \median\left(\frac{S(\bld e)}{\hat\sigma_S}\right), \quad
    M = \mad\left(\frac{S(\bld e)}{\hat\sigma_S}\right),
  \end{equation}
  where $S(e)$ stands for the S-scale estimate evaluated for the actual
  errors $\bld e$. For the D-scale estimate, the definition is
  analogue. Since there is no design to correct for, we set $\tau_i = 1
  \forall i$.  
\item \textbf{Regression estimates.} The efficiency of the regression estimates
  $\bld{\hat\beta}$ is characterized by its mean squared error
  (MSE).  Since we simulate under $H_0: \bld\beta = 0$, this is the
  $L_2$-norm of $\bld{\hat\beta}$.  When comparing to the MSE of the
  ordinary least squares estimate (\emph{OLS}), this gives the efficiency, which,
  by the choice of tuning constants of $\psi$, should yield
  \begin{equation*}
    %% \label{eq:MSE}
    \frac{{\rm MSE}(\bld{\hat\beta}_{\rm OLS})}{{\rm MSE}(\bld{\hat\beta})}
    \approx 0.95
  \end{equation*}
  for standard normally distributed errors. The mean is calculated with
  $\Sexpr{trim*100}\%$ trimming.

  For other error distributions, this ratio should be larger than $1$,
  since by using robust procedures we expect to gain efficency at other
  error distributions (relative to the least squares estimate).
\item $\gamma$. We compare the behaviour of the various estimators of
  $\gamma$ by calculating the trimmed mean and the trimmed standard
  deviation for standard normal distributed errors.
\item \textbf{Covariance matrix estimate.} The covariance matrix estimates
  are compared indirectly over the performance of the resulting test
  statistics. We compare the empirical level of the simple hypothesis tests
  $H_0: \beta_i = 0$ for some $i \in \{1,\dots, p\}$. The power of the
  tests is compared by testing for $H_0: \beta_i = b$ for several values of
  $b>0$. The formal power of a more liberal test is generally
  higher. Therefore, in order for this comparison to be meaningful, the
  individual test statistic was corrected such that all tests have the same
  level of $5\%$. 

  The simple hypothesis tests give only limited insights. To investigate
  the effects of other error distributions, e.g.\ asymmetric error
  distributions, we compare the confidence intervals for the prediction of
  some fixed points. Since it was not clear how to assess the quality
  prediction intervals, either at the central or the simulated model, we do
  not calculate them here.

  A small number of prediction points is already enough, if they  are
  chosen properly. We chose to use seven points lying on the first two
  principal components, spaced evenly from the center of the design used to
  the extended range of the design. The principal components were
  calculated robustly (using \T{covMcd} of the \T{robustbase} package) and
  the range was extended by a fraction of $0.5$. An example is shown in
  Figure~\ref{fig:design-predict}.
\end{itemize}

\subsection{Results}
The results are given here as plots (Fig.~\ref{fig:meanscale-1} to
Fig.~\ref{fig:cpr}). For a complete discussion of the results, we refer to
\citet{KS2010}.

The different $\psi$-functions are each plotted in a different facet,
except for Fig.~\ref{fig:qscale-all}, Fig.~\ref{fig:Mscale-all} and
Fig.~\ref{fig:lqq-level} , where the facets show the results for various
error distributions. The plots are augmented with auxilliary lines to ease
the comparison of the methods. The lines connect the median values for each
simulated ratio $p/n$. In the plots showing the empirical levels, power of
tests and coverage probabilities, Fig.~\ref{fig:emp-level},
Fig.~\ref{fig:lqq-level} and Fig.~\ref{fig:cpr}, the y-axis has been
truncated. Points in the grey shaded area indicate truncated values.

                             
\begin{figure}
\begin{center}
<<label=fig-meanscale,fig=TRUE,echo=FALSE>>=
## ## exp(mean(log(sigma))): this looks almost identical to mean(sigma) 
print(ggplot(test.3, aes(p/n, exp(meanlogsigma.1), color = Est.Scale)) +
      stat_summary(aes(x=ratio), fun.y=median, geom='line') + 
      geom_point(aes(shape = factor(n)), alpha = alpha.n) + 
      geom_hline(yintercept = 1) +
      g.scale_y_log10_1() + 
      facet_wrap(~ Psi) +
      ylab(expression(paste('geometric ',mean(hat(sigma))))) + 
      scale_shape_discrete(expression(n)) +
      scale_colour_discrete("Scale Est."), legend.mod = legend.mod)

## print(ggplot(test.3, aes(p/n, meansigma.1, color = Est.Scale)) +
##       stat_summary(aes(x=ratio), fun.y=median, geom='line') + 
##       geom_point(aes(shape = factor(n)), alpha = alpha.n) + 
##       geom_hline(yintercept = 1) +
##       g.scale_y_log10_1() + 
##       facet_wrap(~ Psi) +
##       ylab(expression(mean(sigma))) + 
##       scale_shape_discrete(expression(n)) +
##       scale_colour_discrete("Scale Est."), legend.mod = legend.mod)
@ 
\end{center}
\caption{Mean of scale estimates for $\Norm{0,1}$ distributed errors. The
  mean is calculated with $\Sexpr{trim*100}\%$ trimming. The lines connect
  the median values for each simulated ratio $p/n$. Results for random
  designs only. }
\label{fig:meanscale-1}
\end{figure}              
                          
\begin{figure}
\begin{center}
<<label=fig-sdscale-1,fig=TRUE,echo=FALSE>>=
print(ggplot(test.3, aes(p/n, sdlogsigma.1*sqrt(n), color = Est.Scale)) +
      stat_summary(aes(x=ratio), fun.y=median, geom='line') + 
      geom_point(aes(shape = factor(n)), alpha = alpha.n) +
      ylab(expression(sd(log(hat(sigma)))*sqrt(n))) +
      ## coord_trans(y = 'sqrt') +
      facet_wrap(~ Psi) +
      scale_shape_discrete(expression(n)) +
      scale_colour_discrete("Scale Est."), legend.mod = legend.mod)
  
## print(ggplot(test.3, aes(p/n, sdsigma.1/meansigma.1*sqrt(n), color = Est.Scale)) +
##       stat_summary(aes(x=ratio), fun.y=median, geom='line') + 
##       geom_point(aes(shape = factor(n)), alpha = alpha.n) +
##       ylab(expression(sd(hat(sigma))*sqrt(n)/mean(hat(sigma)))) +
##       coord_trans(y = 'sqrt') +
##       facet_wrap(~ Psi) +
##       scale_shape_discrete(expression(n)) +
##       scale_colour_discrete("Scale Est."), legend.mod = legend.mod)
@
\end{center}
\caption{Scale efficiency for $\Norm{0,1}$ distributed errors. The standard
  deviation is calculated with $\Sexpr{trim*100}\%$ trimming. 
  % The lines connect the median values for each simulated ratio $p/n$. 
  % Results for random designs only.
}
\label{fig:sdscale-1} 
\end{figure}



\begin{figure}
\begin{center}
<<label=fig-sdscale-all,fig=TRUE,echo=FALSE>>=
print(ggplot(test.4, aes(p/n, sdlogsigma.1*sqrt(n),
                         color = Est.Scale)) +
      stat_summary(aes(x=ratio), fun.y=median, geom='line') + 
      geom_point(aes(shape = Error), alpha = alpha.error) + facet_wrap(~ Psi) +
      ylab(expression(sd(log(hat(sigma)))*sqrt(n))) +
      g.scale_shape() + scale_colour_discrete("Scale Est."), 
      legend.mod = legend.mod)
                         
## print(ggplot(test.4, aes(p/n, sdsigma.1/meansigma.1*sqrt(n),
##                          color = Estimator)) +
##       stat_summary(aes(x=ratio), fun.y=median, geom='line') + 
##       geom_point(aes(shape = Error), alpha = alpha.error) + facet_wrap(~ Psi) +
##       ylab(expression(sd(hat(sigma))*sqrt(n)/mean(hat(sigma)))) + 
##       g.scale_shape(), legend.mod = legend.mod)
@
\end{center}
\caption{Scale efficiency for all simulated error distributions.%  The
  % standard deviation is calculated with $\Sexpr{trim*100}\%$ trimming. The
  % lines connect the median values for each simulated ratio $p/n$. Results
  % for random designs only.
}
\label{fig:sdscale-all} 
\end{figure}

\begin{figure}
\begin{center}
<<label=fig-qscale,fig=TRUE,echo=FALSE>>=
print(ggplot(drop.levels(subset(test.3, Estimator %in% c("SMD", "MM(qE)")),
                         reorder=FALSE), aes(p/n, q, color = Est.Scale)) +
      stat_summary(aes(x=ratio), fun.y=median, geom='line') + 
      geom_point(aes(shape = factor(n)), alpha = alpha.n) + 
      geom_hline(yintercept = 1) +
      g.scale_y_log10_1() + 
      facet_wrap(~ Psi) +
      ylab(expression(q)) + 
      scale_shape_discrete(expression(n)) +
      scale_colour_discrete("Scale Est."), legend.mod = legend.mod)
@ 
\end{center}
\caption{$q$ statistic for $\Norm{0,1}$ distributed errors. $q$ is defined
  in \eqref{eq:def.q.and.M}. % The
  % mean is calculated with $\Sexpr{trim*100}\%$ trimming. The lines connect
  % the median values for each simulated ratio $p/n$. Results for random
  % designs only. 
}
\label{fig:qscale-1}
\end{figure}     

\begin{figure}
\begin{center}
<<label=fig-Mscale,fig=TRUE,echo=FALSE>>=
print(ggplot(drop.levels(subset(test.3, Estimator %in% c("SMD", "MM(qE)")),
                         reorder=FALSE), aes(p/n, M/q, color = Est.Scale)) +
      stat_summary(aes(x=ratio), fun.y=median, geom='line') + 
      geom_point(aes(shape = factor(n)), alpha = alpha.n) + 
      g.scale_y_log10_0.05() + 
      facet_wrap(~ Psi) +
      ylab(expression(M/q)) + 
      scale_shape_discrete(expression(n)) +
      scale_colour_discrete("Scale Est."), legend.mod = legend.mod)
@ 
\end{center}
\caption{$M/q$ statistic for $\Norm{0,1}$ distributed errors. $M$ and $q$ are 
  defined in \eqref{eq:def.q.and.M}.%  The
  % mean is calculated with $\Sexpr{trim*100}\%$ trimming. The lines connect
  % the median values for each simulated ratio $p/n$. Results for random
  % designs only.
}
\label{fig:Mscale-1}
\end{figure}           

\begin{figure}
\begin{center}
<<label=fig-qscale-all,fig=TRUE,echo=FALSE>>=
print(ggplot(drop.levels(subset(test.1, Estimator %in% c("SMD", "MM(qE)") & 
                                Psi == 'bisquare'),
                         reorder=FALSE), aes(p/n, q, color = Est.Scale)) +
      stat_summary(aes(x=ratio), fun.y=median, geom='line') + 
      geom_point(aes(shape = factor(n)), alpha = alpha.n) + 
      geom_hline(yintercept = 1) +
      g.scale_y_log10_1() + 
      facet_wrap(~ Error) +
      ylab(expression(q)) + 
      scale_shape_discrete(expression(n)) +
      scale_colour_discrete("Scale Est."), legend.mod = legend.mod)
@ 
\end{center}
\caption{$q$ statistic for \emph{bisquare} $\psi$. % The
  % mean is calculated with $\Sexpr{trim*100}\%$ trimming. The lines connect
  % the median values for each simulated ratio $p/n$. Results for random
  % designs only. 
}
\label{fig:qscale-all}
\end{figure}


\begin{figure}
\begin{center}
<<label=fig-Mscale-all,fig=TRUE,echo=FALSE>>=
print(ggplot(drop.levels(subset(test.1, Estimator %in% c("SMD", "MM(qE)") & 
                                Psi == 'bisquare'),
                         reorder=FALSE), aes(p/n, M/q, color = Est.Scale)) +
      stat_summary(aes(x=ratio), fun.y=median, geom='line') + 
      geom_point(aes(shape = factor(n)), alpha = alpha.n) + 
      g.scale_y_log10_0.05() + 
      facet_wrap(~ Error) +
      ylab(expression(M/q)) + 
      scale_shape_discrete(expression(n)) +
      scale_colour_discrete("Scale Est."), legend.mod = legend.mod)
@ 
\end{center}
\caption{$M/q$ statistic for \emph{bisquare} $\psi$. % The
  % mean is calculated with $\Sexpr{trim*100}\%$ trimming. The lines connect
  % the median values for each simulated ratio $p/n$. Results for random
  % designs only. 
}
\label{fig:Mscale-all}
\end{figure}        

\clearpage

\begin{figure}
\begin{center}
<<label=fig-efficiency,fig=TRUE,echo=FALSE>>=
print(ggplot(test.2, aes(p/n, efficiency.1, color = Estimator)) +
      geom_point(aes(shape = factor(n)), alpha = alpha.n) +
      geom_hline(yintercept = 0.95) + 
      stat_summary(aes(x=ratio), fun.y=median, geom='line') + 
      ## g.scale_y_log10_1() + 
      facet_wrap(~ Psi) +
      ylab(expression(paste('efficiency of ',hat(beta)))) +
      g.scale_shape(expression(n)) + 
      scale_colour_discrete(name = "Estimator"), legend.mod = legend.mod)
@ 
\end{center}
\caption{Efficiency for standard normal distributed errors. The efficiency
  is calculated by comparing to an OLS estimate and averaging with
  $\Sexpr{trim*100}\%$ trimming. % The lines connect the median values for
  % each simulated ratio $p/n$. Results for random designs only.
}
\label{fig:efficiency}
\end{figure}

\begin{figure}
\begin{center}
<<label=fig-efficiency-all,fig=TRUE,echo=FALSE>>=
print(ggplot(drop.levels(subset(test.1, Error != 't1'), reorder = FALSE),
             aes(p/n, efficiency.1, color = Estimator)) +
      geom_point(aes(shape = Error), alpha = alpha.error) +
      geom_hline(yintercept = 0.95) + 
      stat_summary(aes(x=ratio), fun.y=median, geom='line') + 
      ## g.scale_y_log10_1() + 
      g.scale_shape(value=c(19,17,15,3,7,8,9,1,2,4)[-4]) +
      facet_wrap(~ Psi) + 
      ylab(expression(paste('efficiency of ',hat(beta)))) +
      scale_colour_discrete(name = "Estimator"), legend.mod = legend.mod)
@ 
\end{center}
\caption{Efficiency for all simulated error distributions except $t_1$. % The
  % efficiency is calculated by comparing to an OLS estimate and averaging
  % with $\Sexpr{trim*100}\%$ trimming. The lines connect the median values
  % for each simulated ratio $p/n$. Results for random designs only.
}
\label{fig:efficiency-all}
\end{figure}

\begin{figure}
\begin{center}
<<label=fig-AdB2-1,fig=TRUE,echo=FALSE>>=
print(ggplot(test.2, aes(p/n, AdB2.1/(1-p/n), color = Estimator)) +
      geom_point(aes(shape=factor(n)), alpha = alpha.n) + 
      geom_point(aes(p/n, K2AdB2.1/(1-p/n)), alpha = alpha.n) + 
      geom_point(aes(p/n, AdB2t.1), alpha = alpha.n) +
      stat_summary(aes(x=ratio), fun.y=median, geom='line') + 
      stat_summary(aes(x=ratio, y=K2AdB2.1/(1-p/n)), 
                   fun.y=median, geom='line', linetype = 2) + 
      stat_summary(aes(x=ratio, y=AdB2t.1),
                   fun.y=median, geom='line', linetype = 3) + 
      geom_hline(yintercept = 1/0.95) + 
      g.scale_y_log10_1() + 
      scale_shape_discrete(expression(n)) +
      scale_colour_discrete(name = "Estimator")  +
      ylab(expression(mean(hat(gamma)))) + 
      facet_wrap(~ Psi), legend.mod = legend.mod)
@ 
\end{center}
\caption{Comparing the estimates of $\gamma$. The solid line connects the
  uncorrected estimate, dotted the $\tau$ corrected estimate and
  dashed Huber's small sample correction.%  The
  % mean is caclulated with $\Sexpr{trim*100}\%$ trimming. The lines connect
  % the median values for each simulated ratio $p/n$. Results for random
  % designs only.
}
\label{fig:AdB2-1}
\end{figure}

\begin{figure}
\begin{center}
<<label=fig-sdAdB2-1,fig=TRUE,echo=FALSE>>=
print(ggplot(test.2, aes(p/n, sdAdB2.1/(1-p/n), color = Estimator)) +
      geom_point(aes(shape=factor(n)), alpha = alpha.n) + 
      geom_point(aes((p/n), sdK2AdB2.1/(1-p/n)), alpha = alpha.n) +
      geom_point(aes((p/n), sdAdB2t.1), alpha = alpha.n) +
      stat_summary(aes(x=ratio), fun.y=median, geom='line') + 
      stat_summary(aes(x=ratio, y=sdK2AdB2.1/(1-p/n)),
                   fun.y=median, geom='line', linetype = 2) + 
      stat_summary(aes(x=ratio, y=sdAdB2t.1),
                   fun.y=median, geom='line', linetype = 3) + 
      g.scale_y_log10_0.05() +
      scale_shape_discrete(expression(n)) +
      scale_colour_discrete(name = "Estimator")  +
      ylab(expression(sd(hat(gamma)))) + 
      facet_wrap(~ Psi), legend.mod = legend.mod)
@ 
\end{center}
\caption{Comparing the estimates of $\gamma$. The solid line connects the
  uncorrected estimate, dotted the $\tau$ corrected estimate and
  dashed Huber's small sample correction. % The
  % standard deviation is calculated with $\Sexpr{trim*100}\%$ trimming. The
  % lines connect the median values for each simulated ratio $p/n$. Results
  % for random designs only.
}
\label{fig:sdAdB2-1}
\end{figure}
                             
\begin{figure}
\begin{center}
<<label=fig-emp-level,fig=TRUE,echo=FALSE>>=
print(ggplot(test.2, aes(p/n, f.truncate(emplev_1),
                         color = method.cov)) +
      g.truncate.lines + g.truncate.areas + 
      geom_point(aes(shape = factor(n)), alpha = alpha.n) +
      scale_shape_discrete(expression(n)) +
      stat_summary(aes(x=ratio), fun.y=median, geom='line') + 
      geom_hline(yintercept = 0.05) +
      g.scale_y_log10_0.05() +
      scale_colour_discrete(name = "Estimator")  +
      ylab(expression(paste("empirical level ", (beta[1])))) + 
      facet_wrap(~ Psi), legend.mod = legend.mod)
@ 
\end{center}
\caption{Empirical levels for $\beta_1$ and $\Norm{0,1}$ distributed
  errors. The y-values are truncated at $\Sexpr{trunc[1]}$ and
  $\Sexpr{trunc[2]}$. % The lines connect the median values for each
  % simulated ratio $p/n$. Results for random designs only.
}
\label{fig:emp-level}
\end{figure}
    
\begin{figure}
\begin{center}
<<label=fig-lqq-level,fig=TRUE,echo=FALSE>>=
print(ggplot(drop.levels(subset(test.1, Psi == 'lqq' & emplev_1 != 0), 
                         reorder = FALSE),
      aes(p/n, f.truncate(emplev_1), color = method.cov)) +
      g.truncate.line + g.truncate.area +
      geom_point(aes(shape = factor(n)), alpha = alpha.n) +
      stat_summary(aes(x=ratio), fun.y=median, geom='line') + 
      ## stat_smooth(se = FALSE, method = 'loess') + 
      ## stat_smooth(se = FALSE, method = 'lmRob', formula = y ~ poly(x, 4)) + 
      geom_hline(yintercept = 0.05) + 
      g.scale_y_log10_0.05() +
      g.scale_shape(expression(n)) + 
      scale_colour_discrete(name = "Estimator") + 
      ylab(expression(paste("empirical level ", (beta[1])))) + 
      facet_wrap(~ Error), legend.mod = legend.mod
      )
@ 
\end{center}
\caption{Empirical levels for $\beta_1$ and \emph{lqq} $\psi$-function. The
  y-values are truncated at $\Sexpr{trunc[2]}$. % The lines connect the
  % median values for each simulated ratio $p/n$. Results for random designs
  % only.
}
\label{fig:lqq-level}
\end{figure}


\begin{figure}
\begin{center}
<<label=fig-power-1-0_2,fig=TRUE,echo=FALSE>>=
print(ggplot(subset(test.1, n == 25),
      aes(p/n, power_1_0.2, color = method.cov)) +
      geom_point(aes(shape = Error), alpha = alpha.error) +
      stat_summary(aes(x=p/n), fun.y=median, geom='line') + 
      ## g.scale_y_log10_1() +
      g.scale_shape("Error") + 
      scale_colour_discrete(name = "Estimator (Cov. Est.)") + 
      ylab(expression(paste("empirical power ", (beta[1])))) + 
      facet_wrap(~ Psi), legend.mod = legend.mod
      )
@ 
\end{center}
\caption{Empirical power for test $H_0: \beta_1 = 0.2$. Results for $n =
  25$ displayed only. % The lines connect the median values for each
  % simulated ratio $p/n$. Results for random designs only.
}
\label{fig:power-1-0_2}
\end{figure}

\begin{figure}
\begin{center}
<<label=fig-power-1-0_4,fig=TRUE,echo=FALSE>>=
print(ggplot(subset(test.1, n == 25),
      aes(p/n, power_1_0.4, color = method.cov)) +
      geom_point(aes(shape = Error), alpha = alpha.error) +
      stat_summary(aes(x=p/n), fun.y=median, geom='line') + 
      ## g.scale_y_log10_1() +
      g.scale_shape("Error") + 
      scale_colour_discrete(name = "Estimator (Cov. Est.)") + 
      ylab(expression(paste("empirical power ", (beta[1])))) + 
      facet_wrap(~ Psi), legend.mod = legend.mod
      )
@ 
\end{center}
\caption{Empirical power for test $H_0: \beta_1 = 0.4$. Results for $n =
  25$ displayed only. % The lines connect the median values for each
  % simulated ratio $p/n$. Results for random designs only.
}
\label{fig:power-1-0_4}
\end{figure}

\begin{figure}
\begin{center}
<<label=fig-power-1-0_6,fig=TRUE,echo=FALSE>>=
print(ggplot(subset(test.1, n == 25),
      aes(p/n, power_1_0.6, color = method.cov)) +
      geom_point(aes(shape = Error), alpha = alpha.error) +
      stat_summary(aes(x=p/n), fun.y=median, geom='line') + 
      ## g.scale_y_log10_1() +
      g.scale_shape("Error") + 
      scale_colour_discrete(name = "Estimator (Cov. Est.)") + 
      ylab(expression(paste("empirical power ", (beta[1])))) + 
      facet_wrap(~ Psi), legend.mod = legend.mod
      )
@ 
\end{center}
\caption{Empirical power for test $H_0: \beta_1 = 0.6$. Results for $n =
  25$ displayed only.%  The lines connect the median values for each
  % simulated ratio $p/n$. Results for random designs only.
}
\label{fig:power-1-0_6}
\end{figure}

\begin{figure}
\begin{center}
<<label=fig-power-1-0_8,fig=TRUE,echo=FALSE>>=
print(ggplot(subset(test.1, n == 25),
      aes(p/n, power_1_0.8, color = method.cov)) +
      geom_point(aes(shape = Error), alpha = alpha.error) +
      stat_summary(aes(x=p/n), fun.y=median, geom='line') + 
      ## g.scale_y_log10_1() +
      g.scale_shape("Error") + 
      scale_colour_discrete(name = "Estimator (Cov. Est.)") + 
      ylab(expression(paste("empirical power ", (beta[1])))) + 
      facet_wrap(~ Psi), legend.mod = legend.mod
      )
@ 
\end{center}
\caption{Empirical power for test $H_0: \beta_1 = 0.8$. Results for $n =
  25$ displayed only. % The lines connect the median values for each
  % simulated ratio $p/n$. Results for random designs only.
}
\label{fig:power-1-0_8}
\end{figure}

\begin{figure}
\begin{center}
<<label=fig-power-1-1,fig=TRUE,echo=FALSE>>=
print(ggplot(subset(test.1, n == 25),
      aes(p/n, power_1_1, color = method.cov)) +
      geom_point(aes(shape = Error), alpha = alpha.error) +
      stat_summary(aes(x=p/n), fun.y=median, geom='line') + 
      ## g.scale_y_log10_1() +
      g.scale_shape("Error") + 
      scale_colour_discrete(name = "Estimator (Cov. Est.)") + 
      ylab(expression(paste("empirical power ", (beta[1])))) + 
      facet_wrap(~ Psi), legend.mod = legend.mod
      )
@ 
\end{center}
\caption{Empirical power for test $H_0: \beta_1 = 1$. Results for $n =
  25$ displayed only. % The lines connect the median values for each
  % simulated ratio $p/n$. Results for random designs only.
}
\label{fig:power-1-1}
\end{figure}

\clearpage

\begin{figure}
\begin{center}
<<label=fig-pred-points,fig=TRUE,echo=FALSE>>=
## pairs(rbind(dd, f.prediction.points(dd)[1:7,]), 
##       col = c(rep(1, 20), rep(2, 7)), 
##       pch = c(rep("o", 20), as.character(1:7)))

pp <- f.prediction.points(dd)[1:7,]
tmp <- plotmatrix(pp)$data
tmp$label <- as.character(1:7)
print(plotmatrix(dd) + geom_text(data=tmp, color = 2, aes(label=label), size = 2.5))
  ## geom_text(data = tmp, aes(label=label, x = x + 0.5, y = y + 0.5),
  ##           size = 3)
@ 
\end{center}
\caption{Prediction points for fixed design. The black points are the
  points of the original design. The red digits indicate the numbers and
  locations of the points where predictions are taken.}
\label{fig:design-predict}
\end{figure}


\begin{figure}
\begin{center}
<<label=fig-cpr,fig=TRUE,echo=FALSE>>=
n.cprs <- names(test.fixed)[grep('cpr', names(test.fixed))]
test.5 <- melt(test.fixed[,c('method.cov', 'Error', 'Psi', n.cprs)])
test.5 <- within(test.5, {
  ltmp <- as.numeric(do.call('rbind', strsplit(levels(variable), '_'))[,2])
  Point <- ltmp[variable]
  ltmp <- NULL
})
print(ggplot(test.5,
             aes(Point, f.truncate(value), color = method.cov)) +
      geom_point(aes(shape = Error), alpha = alpha.error) +
      g.truncate.line + g.truncate.area + 
      ## stat_summary(fun.y=median, geom='point', shape = '—', size = 3) + 
      stat_summary(fun.y=median, geom='line') + 
      geom_hline(yintercept = 0.05) +
      g.scale_y_log10_0.05() +
      g.scale_shape() + 
      scale_colour_discrete(name = "Estimator (Cov. Est.)") + 
      ylab("empirical level of confidence intervals") + 
      facet_wrap(~ Psi), legend.mod = legend.mod
      )
@ 
\end{center}
\caption{Empirical coverage probabilities. Results for fixed design. The
  y-values are truncated at $\Sexpr{trunc[2]}$. % The lines connect the
  % median values for each point.
}
\label{fig:cpr}
\end{figure}


\clearpage

\section{Maximum Asymptotic Bias} 
\label{sec:maximum-asymptotic-bias}

The slower redescending $\psi$-functions come with higher asymptotic bias
as illustrated in Fig.~\ref{fig:max-asymptotic-bias}. We calculate the
asymptotic bias as in \citet{berrendero2007maximum}.


<<results=HIDE,echo=FALSE>>=
## Henning (1994) eq 33: 
g <- Vectorize(function(s, theta, mu, ...) {
  lctrl <- lmrob.control(...)
  rho <- function(x)
    robustbase:::lmrob.chifun(x, lctrl$tuning.chi, lctrl$psi, deriv = 0)
  integrate(function(x) rho(((1 + theta^2)/s^2*x)^2)*dchisq(x, 1, mu^2/(1 + theta^2)),
            -Inf, Inf)$value
})
## Martin et al 1989 Section 3.2: for mu = 0
g.2 <- Vectorize(function(s, theta, mu, ...) {
  lctrl <- lmrob.control(...)
  lctrl$tuning.psi <- lctrl$tuning.chi
  robustbase:::lmrob.E(chi(sqrt(1 + theta^2)/s*r), lctrl, use.integrate = TRUE)})
g.2.MM <- Vectorize(function(s, theta, mu, ...) {
  lctrl <- lmrob.control(...)
  robustbase:::lmrob.E(chi(sqrt(1 + theta^2)/s*r), lctrl, use.integrate = TRUE)})
## Henning (1994) eq 30, one parameter case 
g.3 <- Vectorize(function(s, theta, mu, ...) {
  lctrl <- lmrob.control(...)
  rho <- function(x)
    robustbase:::lmrob.chifun(x, lctrl$tuning.chi, lctrl$psi, deriv = 0)
  int.x <- Vectorize(function(y) {
    integrate(function(x) rho((y - x*theta - mu)/s)*dnorm(x)*dnorm(y),-Inf, Inf)$value })
  integrate(int.x,-Inf, Inf)$value
})
inv.g1 <- function(value, theta, mu, ...) {
  g <- if (mu == 0) g.2 else g.3
  uniroot(function(s) g(s, theta, mu, ...) - value, c(0.1, 100))$root
}
inv.g1.MM <- function(value, theta, mu, ...) {
  g <- if (mu == 0) g.2.MM else g.3.MM
  ret <- try(uniroot(function(s) g(s, theta, mu, ...) - value, c(0.01, 100)),
             silent = TRUE)
  if (class(ret)[1] == 'try-error') {
    warning('inv.g1.MM: ', value, ' ', theta, ' ', mu)
    NA
  } else {
    ret$root
  }
}  
s.min <- function(epsilon, ...) inv.g1(0.5/(1 - epsilon), 0, 0, ...)
s.max <- function(epsilon, ...) inv.g1((0.5-epsilon)/(1-epsilon), 0, 0, ...)

BS <- Vectorize(function(epsilon, ...) {
  sqrt(s.max(epsilon, ...)/s.min(epsilon, ...)^2 - 1) })

l <- Vectorize(function(epsilon, ...) {
  sigma_be <- s.max(epsilon, ...)
  sqrt((sigma_be/inv.g1.MM(g.2.MM(sigma_be,0,0,...) + 
                           epsilon/(1-epsilon),0,0,...))^2 - 1) })
u <- Vectorize(function(epsilon, ...) {
  gamma_be <- s.min(epsilon, ...)
  max(l(epsilon, ...),
      sqrt((gamma_be/inv.g1.MM(g.2.MM(gamma_be,0,0,...) + 
                               epsilon/(1-epsilon),0,0,...))^2 - 1)) })
@
                             
\begin{figure}
\begin{center}
<<label=fig-max-asymptotic-bias,fig=TRUE,echo=FALSE>>=
if (!file.exists('asymptotic.max.bias.Rdata')) {
  x <- seq(0, 0.35, length.out = 100)
  rmb <- rbind(data.frame(l=l(x, psi = 'hampel'), 
                          u=u(x, psi = 'hampel'), psi = 'Hampel'),
               data.frame(l=l(x, psi = 'lqq'), 
                          u=u(x, psi = 'lqq'), psi = 'lqq'),
               data.frame(l=l(x, psi = 'bisquare'), 
                          u=u(x, psi = 'bisquare'), psi = 'bisquare'), 
               data.frame(l=l(x, psi = 'optimal'), 
                          u=u(x, psi = 'optimal'), psi = 'optimal'))
  rmb$x <- x
  save(rmb, file='asymptotic.max.bias.Rdata')
} else load('asymptotic.max.bias.Rdata')

print(ggplot(rmb, aes(x, l, color=psi)) + 
      geom_line() + geom_line(aes(x, u, color=psi, linetype = 2)) + 
      coord_cartesian(ylim=c(0,10)) + 
      scale_y_continuous(breaks = 1:10) + 
      scale_colour_hue(expression(paste(psi,'-function'))) + 
      xlab(expression(paste("amount of contamination  ", epsilon))) +
      ylab("maximum asymptotic bias bounds"))
@ 
\end{center}
\caption{Maximum asymptotic bias bound for the $\psi$-functions used in the
  simulation. Solid line: lower bound. Dashed line: upper bound.}
\label{fig:max-asymptotic-bias}
\end{figure}

\bibliographystyle{chicago}
\bibliography{lmrob_simulation}

\end{document}
