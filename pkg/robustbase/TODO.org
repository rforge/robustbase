				[MM:  grep-r -e '\(FIXME\|TODO\)'  ]
* glmrob
**  BYlogreg()  [ R/BYlogreg.R ]
   --> more tests in ./tests/glmrob-1.R
   --> glm.fit() instead of glm()
   --> vcov() instead of just std.err. {is already there}

** glmrob(*, weights.on.x = "robCov")  uses  MASS::cov.rob(),
  i.e. "MVE" and Andreas had a comment that "mcd" is worse.
  "covMcd" has been available for a while; now via robXweights() in ./R/glmrobMqle.R
  HOWEVER: Need something better when 'X' has (binary!) factors!
  "hat" +- works, but needs more work

** We now allow  weights.on.x  to be an arbitrary general  wts(X, intercept)
  function _or_ a list containing a  robMcd()-like function.
  Definitely need *testing* this situation!

** glmrob(<Gamma>):  anova() has  three variants: "V1", "Eva1", "Andreas1"
   --> ./R/glmrobMqle-DQD.R
   - gives warning every time {-> easy to fix}
   -  Default is "V1" is that a good idea?


** glmrob() needs a bit more tests in ./tests/
           [also consider those from man/glmrob.Rd]
   take those from Martin's old 'robGLM1' package (need more!)
**  --> first test already shows that Martin's tests for "huberC == Inf"
      were *not* yet moved from robGLM1 to glmrob()...
   (in other words:  glmrob() should work

** also, ni = 0 does not work quite as it should ( ./tests/binom-ni-small.R )

** obj $ df ...  maybe should be defined -- for "glm" methods to be
  applicable  --> e.g. for predict(<glmrob>, interval="..") !

** summary.glmrob() should be better documented;
  we should decide if the current return value is fine.

** Eva's code (and MM's) also computed & returned the "asymptotic efficiency"!

** anova.glmrob(): More modularization, allowing to provide own 'test' function.
  Test if Huber's C are different. Need theory to compare different C's and
  same model (which includes classical vs robust).

** add1() and/or drop1() would be nice


* Psi/Rho/Chi/Wgt Functions
   Our "mess":  We have quite a few "partial" collections of rho/psi functions:

** 1) have the nice S4 class psi_func  + psiFunc() and .defDwgt() functions in

      ./R/psi-rho-funs.R    with explorations, ideas in
      ~~~~~~~~~~~~~~~~~~
      ./experi-psi-rho-funs.R

** 2) have "old" tukeyChi() & tukeyPsi1()  originally called from lmrob() , in
      ./R/biweight-funs.R
** 3) psi.*(....,  rho = FALSE/TRUE)   functions from Andreas
      should be replaced by using the new  psi_func  objects
      ./R/psi-funs-AR.R  &  ./man/pkg-internal.Rd
      ~~~~~~~~~~~~~~~~~  ===> Change  nlrob() slightly: allowing 'psi'
      to be a function *or* a psiFunc:
      --> ./R/nlrob.R+psi ./man/nlrob.Rd+psi
      Before that we *do* need "real" checks (numbers!) for nlrob

** 4) have the C-based functions, now used from lmrob(), in
      ./R/lmrob.MM.R

      now called  Mpsi(), Mchi(), Mwgt() plus new MrhoInf()
      {now exported and documented in man/M.psi.Rd }

    Further files, illustrating features, differences, etc:

	./inst/doc/psi_functions.Rnw -- with quite a few FIXME
	 ~~~~~~~~~~~~~~~~~~~~~~~~~~~

	./inst/xtraR/plot-psiFun.R	chkPsiDeriv() {and plot utils}
	./tests/psi-rho-etc.R   	compute asymp.efficiency and breakdown point !
	./tests/lmrob-psifns.R 	   	plot and lmrob()-test them

    TODO: Done: -> '32)'; Rest:
	   .) *Deprecate* the "2)", tukeyChi() etc, making them call the M.*fun():
	      *CARE*: tukeyPsi1(*, d = 2) is now needed asymp.cov() of glmrobMT()
           .) provide  '1)'-i.e. psi_func  versions of them

    *) Mpsi(*, "GGW") etc :  there is (??) no reasonable to directly specify
       ---------------- the (a,b,c) tuning parameters


* New  lmrob() "M-S" etc features:

** Function names with "." (which are exported) are frowned upon
     e.g.  lmrob.split()

** checking .vcov.avar1() and its "posdefify" options ??

** lmrob.mar() [ inst/doc/estimating.functions.R ]: should become part
   ~~~~~~~~~~  of robustbase, maybe under a better name,
      e.g. via lmrob( ... control ..) or directly.
     It is much used in the simulations of Koller & Stahel (2011)

** Provide "simple M" estimator [so MASS :: rlm() is entirely superseeded]
   Consider lmrob(*,  method = "M") --> default init = "ls" (Least Sq; as MASS:::rlm.default)
   which calls  lmrob..M..fit() which is already documented as "simple"
   M-estimator (though the *scale* is kept fixed; i.e., no  'proposal 2').

* inst/doc/lmrob_simulation.Rnw :
** use hyperlinks {e.g. using jss docu.class!}
** consider making parts available in (new) ./demo/lmrob...R
** tau_i (p.5)  is not clear for  Joe Average.

..........................................

* Generalizing  'wgt.himedian':  We'd want a C API on which R builds.

   There are pure R implementations:
    - 'weighted.median()' in limma
    	 and I have generalized it ---> inst/ex-funs.R
    - more general code (different 'tie' strategies; weighted *quantile*s)
      in /u/maechler/R/MM/STATISTICS/robust/weighted-median.R
    - The 'Hmisc' package has wtd.quantile()

* covOGK():
  The argument name 'weight.fn' is pretty ugly and the default function
  name 'hard.rejection()' is just awful (we need a globally available
  function as 'role model'.

  - Could allow 'n.iter = 0' to simply compute Cov()_{ij} = rcov(X_i, X_j)

* scaleTau2():  Also do a cheap finite-sample correction [MM] !
		[done partly; but undocumented, since bound to change]

* rrcov etc

** rrcov.control() __ NEEDS  name change ! ______
   probably use  mcd.control() and lts.control()

   or forget about *control() completely?
   since there are only a few in each ??????/

** tolellipse() --> renamed to tolEllipsePlot()
*** maybe use  cluster::ellipsoidPoints()
*** allow other percentiles than just  97.5%
*** maybe *return* something

** plot(mcd. ) [ R/covPlot.R ] : should show the call
	     Default for 'ask' should be smarter: depend on
	     prod(par("mfrow")) < #{plots} (which depends on 'classic' and p=2)

** ltsReg():  has  undocumented '$resid'
	     in addition to '$residuals' and '$raw.residuals';
	     drop it or document it !

* nlrob()

** residuals( nlrob(), type = "...") should provide types "as in the litterature"

** nlrob(*, method = "...") should call methods "tau", "CM", "MTL", "MM"
   by Eduardo Conceicao

*** TODO: shouldn't we rename jde() to jdeopt() or even jdeoptim(), jDEoptim(), or JDEoptim()
R users already know optim() etc.. so the name seems more logical for them.

* More lmrob() considerations
** DONE more tests in	tests/

** fully implement and test the multivariate case (y = matrix with > 1 col.)
** src/lmrob.c :
    does median() , MAD() instead of using R's  sort() routines

* Misceallanous
** Add data sets from the MMY-book -- mostly done {do we have *all* ?}


** Alternative version of covOGK() for correlation-only
  using's Huber's correlation formula which ensures [-1,1] range
  --> ~/R/MM/Pkg-ex/robustbase/robcorgroesser1.R
  and ~/R/MM/STATISTICS/robust/pairwise-new.R

** package 'riv' (author @ epfl.ch!) has 'slc()'  ~=  cov.S(.)  -- in pure R code
  doesn't Valentin have a version too?
  otherwise: test this, ask author for "donation" to robustbase

** adjOutlyingness() :
    typo-bug is corrected; and I have made it more pretty.
    Still a bit problematic when denominator = 0
    Currently leave away all the c/0 = Inf and 0/0 = NaN values.

    MM: Maybe, it's the fact that the   coef = 1.5  should really depend on
        the sample size  n   and will be too large for small n (??)
  --> should ask Mia and maybe Guy Brys

